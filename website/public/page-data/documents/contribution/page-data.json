{"componentChunkName":"component---src-pages-documents-markdown-remark-parent-file-name-js","path":"/documents/contribution/","result":{"data":{"markdownRemark":{"html":"<h1>如何贡献ChunJun</h1>\n<p>本文面向ChunJun插件开发人员，尝试通过一个开发者的角度尽可能全面地阐述一个ChunJun插件所经历的过程，同时消除开发者的困惑，快速上手插件开发。</p>\n<p>从数据流的角度来看ChunJun，可以理解为不同数据源的数据流通过对应的ChunJun插件处理，变成符合ChunJun数据规范的数据流；脏数据的处理可以理解为脏水流通过污水处理厂，变成符合标准，可以使用的水流，而对不能处理的水流收集起来。</p>\n<p>插件开发不需要关注任务具体如何调度，只需要关注关键问题：</p>\n<ol>\n<li>数据源本身读写数据的正确性；</li>\n<li>如何合理且正确地使用框架；</li>\n<li>配置文件的规范；</li>\n</ol>\n<p><a name=\"29c80db5\"></a></p>\n<h2>开发环境</h2>\n<ul>\n<li>Flink集群: 1.4及以上(单机模式不需要安装Flink集群）</li>\n<li>Java: JDK8及以上</li>\n<li>操作系统：理论上不限，但是目前只编写了shell启动脚本，用户可以可以参考shell脚本编写适合特定操作系统的启动脚本。</li>\n</ul>\n<p>开发之前，需要理解以下概念：</p>\n<p><a name=\"f1105542\"></a></p>\n<h2>逻辑执行概念</h2>\n<p>插件开发者不需要关心太多整个框架的具体运行，只需要关注数据源的读写，以及代码在逻辑上是怎么被执行的，方法什么时候被调用的。以下概念的理解对你快速开发会有帮助：</p>\n<ul>\n<li><strong>Job</strong>：** Job**是ChunJun用以描述从一个源头到一个目的端的同步作业，是ChunJun数据同步的最小业务单元。</li>\n<li><strong>Internal</strong>： 把<strong>Job</strong>拆分得到的最小执行单元。</li>\n<li><strong>InputSplit</strong>：数据切片，是进入Internal的最小数据流单位。里面包含了基本数据信息和统计信息。</li>\n<li><strong>InputFormat</strong>：读插件的执行单位。</li>\n<li><strong>OutputFormat</strong>：写插件的执行单位。</li>\n</ul>\n<p><a name=\"209c6aed\"></a></p>\n<h2>任务执行模式</h2>\n<ul>\n<li>单机模式：对应Flink集群的单机模式</li>\n<li>standalone模式：对应Flink集群的分布式模式</li>\n<li>yarn模式：对应Flink集群的yarn模式</li>\n<li>yarnPer模式: 对应Flink集群的Per-job模式</li>\n</ul>\n<p>在实际开发中，上述几种模式对插件的编写没有过多的影响，一般在本地LocalTest通过，将任务上传到Flink集群测试没有什么大问题。</p>\n<p><a name=\"92411f2e\"></a></p>\n<h2>插件入口类</h2>\n<p>插件的入口类需继承<strong>DataReader</strong>和<strong>DataWriter</strong>，在内部获取任务json传来的参数，通过相应的<strong>Builder</strong>构建对应<strong>InputFormat</strong>和<strong>OutputFormat</strong>实例</p>\n<p><a name=\"DataReader\"></a></p>\n<h3>DataReader</h3>\n<pre><code class=\"language-java\">public class SomeReader extends DataReader {\r\n    protected String oneParameter;\r\n    public SomeReader(DataTransferConfig config, StreamExecutionEnvironment env) {\r\n        super(config, env);\r\n    }\r\n    @Override\r\n    public DataStream&#x3C;Record> readData() {\r\n        return null;\r\n    }\r\n}\n</code></pre>\n<p>reader类需继承DataReader，同时重写readData方法。在构造函数中获取任务json中构建InputFormat所需要的参数，代码案例如下：</p>\n<p>构造方法</p>\n<pre><code class=\"language-java\">protected String oneParameter;\r\npublic SomeReader(DataTransferConfig config, StreamExecutionEnvironment env) {\r\n    super(config, env);\r\n    // 首先通过jobconfig获取任务json中reader信息\r\n    ReaderConfig readerConfig = config.getJob().getContent().get(0).getReader();\r\n    // 通过getParameter()获取相应的参数信息\r\n    oneParameter = readerConfig.getParameter().getStringVal(SomeConfigKeys.KEY_PARAMETER);\r\n}\n</code></pre>\n<p>重写readData方法</p>\n<pre><code class=\"language-java\">@Override\r\npublic DataStream&#x3C;Record> readData() {\r\n    // 通过Builder构建InputFormat\r\n    SomeInputFormatBuilder builder = new SomeInputFormatBuilder(new SomeInputFormat());\r\n    // 一个setOneParameter()方法只set一个参数\r\n    builder.setOneParameter(OneParameter);\r\n    //调用createInput返回一个DataStream实例\r\n    return createInput(builder.finish());\r\n}\n</code></pre>\n<p><a name=\"DataWriter\"></a></p>\n<h3>DataWriter</h3>\n<pre><code class=\"language-java\">public class SomeWriter extends DataWriter {\r\n    protected String oneParameter;\r\n    public SomeWriter(DataTransferConfig config) {\r\n        super(config);\r\n    }\r\n\r\n    @Override\r\n    public DataStreamSink&#x3C;?> writeData(DataStream&#x3C;Record> dataSet) {\r\n        return null;\r\n    }\r\n}\n</code></pre>\n<p>和DataReader类似，writer需继承DataWriter，同时重写writeData方法。通常会创建一个ConfigKeys类，包含reader和writer所有需要的使用的任务json中参数的key。</p>\n<p>构造方法</p>\n<pre><code class=\"language-java\">protected String oneParameter;\r\npublic SomeWriter(DataTransferConfig config) {\r\n    super(config);\r\n    // 首先通过jobconfig获取jobjson中writer信息\r\n    WriterConfig writerConfig = config.getJob().getContent().get(0).getWriter();\r\n\toneParameter = writerConfig.getParameter().getStringVal(SomeConfigKeys.KEY_PARAMETER);\r\n}\n</code></pre>\n<p>重写writeData方法</p>\n<pre><code class=\"language-java\">@Override\r\npublic DataStreamSink&#x3C;?> writeData(DataStream&#x3C;Record> dataSet) {\r\n    // 通过Builder构建OutputFormat\r\n    SomeOutputFormatBuilder builder = new SomeOutputFormatBuilder(new SomeOutputFormat());\r\n    // 一个setOneParameter()方法只set一个参数\r\n    builder.setOneParameter(OneParameter);\r\n    //调用createInput返回一个DataSink实例\r\n    return createInput(builder.finish());\r\n}\n</code></pre>\n<p><a name=\"e3fa8e04\"></a></p>\n<h3>InputFormatBuilder的设计</h3>\n<p>需继承<strong>RichInputFormatBuilder</strong></p>\n<pre><code class=\"language-java\">public class SomeInputFormatBuilder extends RichInputFormatBuilder {\r\n    /**\r\n    * 首先实例化一个InputFormat实例，通过构造函数传递，通过set方法设置参数\r\n    */\r\n    protected SomeInputFormat format;\r\n    //InputFormat构造函数，需要给实例化父类的format\r\n    public SomeInputFormatBuilder(SomeInputFormat format){\r\n        super.format = this.format = format;\r\n    }\r\n    //set方法示例，建议set方法内只给一个变量赋值\r\n    public void setOneParameter(String oneParameter){\r\n        this.oneParameter = oneParameter;\r\n    }\r\n    //重写checkFormat，检查一些必要参数设置是否正确\r\n    @Override\r\n    protected void checkFormat() {}\r\n}\n</code></pre>\n<p><a name=\"debbb760\"></a></p>\n<h3>InputFormat的设计</h3>\n<p>需继承<strong>RichInputFormat</strong>，根据任务逻辑分别实现</p>\n<pre><code class=\"language-java\">public class SomeInputFormat extends RichInputFormat {\r\n    @override\r\n    public void openInputFormat() {\r\n        \r\n    }\r\n    \r\n    @override\r\n    public void closeInputFormat() {\r\n    }\r\n    \r\n    @Override\r\n    protected void openInternal(InputSplit inputSplit) throws IOException {\r\n    }\r\n\r\n    @Override\r\n    protected Row nextRecordInternal(Row row) throws IOException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    protected void closeInternal() throws IOException {\r\n    }\r\n\r\n    @Override\r\n    public void configure(Configuration parameters) {\r\n    }\r\n\r\n    @Override\r\n    public InputSplit[] createInputSplits(int minNumSplits) throws IOException {\r\n        return new InputSplit[0];\r\n    }\r\n\r\n    @Override\r\n    public boolean reachedEnd() throws IOException {\r\n        return false;\r\n    }\r\n}\n</code></pre>\n<p>方法功能如下：\r\n<a name=\"qxRB6\"></a></p>\n<h4>configure</h4>\n<ul>\n<li>调用位置：configure方法会在JobManager里构建执行计划的时候和在TaskManager里初始化并发实例后各调用一次；</li>\n<li>作用：用于配置task的实例；</li>\n<li>注意事项：不要在这个方法里写耗时的逻辑，比如获取连接，运行sql等，否则可能会导致akka超</li>\n</ul>\n<p><a name=\"P6eAb\"></a></p>\n<h4>createInputSplits</h4>\n<ul>\n<li>调用位置：在构建执行计划时调用；</li>\n<li>作用：调用子类的逻辑生成数据分片；</li>\n<li>注意事项：分片的数量和并发数没有严格对应关系，不要在这个方法里做耗时的操作，否则会导致akka超时异常；</li>\n</ul>\n<p><a name=\"Oas9f\"></a></p>\n<h4>getInputSplitAssigner</h4>\n<ul>\n<li>调用位置：创建分片后调用；</li>\n<li>作用：获取分片分配器，同步插件里使用的是DefaultInputSplitAssigner，按顺序返回分配给各个并发实例；</li>\n<li>注意事项：无；</li>\n</ul>\n<p><a name=\"TTNYz\"></a></p>\n<h4>openInternal</h4>\n<ul>\n<li>调用位置：开始读取分片时调用；</li>\n<li>作用：用于打开需要读取的数据源，并做一些初始化；</li>\n<li>注意事项：这个方法必须是可以重复调用的，因为同一个并发实例可能会处理多个分片；</li>\n</ul>\n<p><a name=\"hxlFZ\"></a></p>\n<h4>reachEnd和nextRecordInternal</h4>\n<ul>\n<li>调用位置：任务运行时，读取每条数据时调用；</li>\n<li>作用：返回结束标识和下一条记录；</li>\n<li>注意事项：无</li>\n</ul>\n<p><a name=\"bMWCr\"></a></p>\n<h4>closeInternal</h4>\n<ul>\n<li>调用位置：读取完一个分片后调用，至少调用一次；</li>\n<li>作用：关闭资源；</li>\n<li>注意事项：可重复调用，关闭资源做非null检查，因为程序遇到异常情况可能直接跳转到closeInternal；</li>\n</ul>\n<p><a name=\"FcsIE\"></a></p>\n<h4>openInputFormat</h4>\n<ul>\n<li>调用位置：创建分片之后调用；</li>\n<li>作用：对整个InpurFormat资源做初始化；</li>\n<li>注意事项：无；</li>\n</ul>\n<p><a name=\"1CyCJ\"></a></p>\n<h4>closeInputFormat</h4>\n<ul>\n<li>调用位置：当所有切片都执行完之后调用；</li>\n<li>作用：关闭整个InputFormat的资源；</li>\n<li>注意事项：无；</li>\n</ul>\n<p><a name=\"OutputFormatBuilder\"></a></p>\n<h3>OutputFormatBuilder</h3>\n<p>需继承<strong>RichOutputFormatBuilder</strong>，和<strong>InputFormatBuilder</strong>相似</p>\n<pre><code class=\"language-java\">public class SomeOutputFormatBuilder extends RichOutputFormatBuilder {\r\n    /**\r\n    * 首先实例化一个OutputFormat实例，通过构造函数传递，通过设计set方法设置参数\r\n    * 如下演示\r\n    */\r\n    protected SomeOutputFormat format;\r\n    \r\n    public SomeOutputFormatBuilder(SomeOutputFormat format){\r\n        super.format = this.format = format;\r\n    }\r\n    \r\n    public void setOneParameter(String oneParameter){\r\n        this.oneParameter = oneParameter;\r\n    }\r\n    \r\n    //重写checkFormat，检查参数设置是否正确\r\n    @Override\r\n    protected void checkFormat() {}\r\n}\n</code></pre>\n<p><a name=\"OutputFormat\"></a></p>\n<h3>OutputFormat</h3>\n<p>需继承<strong>RichOutputFormat</strong></p>\n<pre><code class=\"language-java\">public class SomeOutputFormat extends RichOutputFormat {\r\n \t@Override\r\n    protected void openInternal(int taskNumber, int numTasks) throws IOException {}\r\n    \r\n    @Override\r\n    protected void writeSingleRecordInternal(Record record) {\r\n    }\r\n    \r\n    @Override\r\n    protected void writeMultipleRecordsInternal() throws Exception {\r\n    }\r\n}\n</code></pre>\n<p>各方法的执行逻辑如下：</p>\n<p>openInternal -> writeSingleRecordInternal / writeMultipleRecordsInternal</p>\n<p>对于是执行writeSingleRecordInternal 还是writeMultipleRecordsInternal，关键参数是batchInterval，当batchInterval=1 时，框架调用writeSingleRecordInternal；当batchInterval > 1 且 record != null时，则调用writeMultipleRecordsInternal</p>\n<p>方法功能如下：\r\n<a name=\"vaLIS\"></a></p>\n<h4>openInternal</h4>\n<ul>\n<li>调用位置：开始写入使用</li>\n<li>作用：用于打开需要读取的数据源，并做一些初始化；</li>\n<li>注意事项：无；</li>\n</ul>\n<p><a name=\"Zbwct\"></a></p>\n<h4>writerSingleRecordInternal</h4>\n<ul>\n<li>调用位置：openInernal之后调用，开始写入数据</li>\n<li>作用：向数据源写入一条数据</li>\n<li>注意事项：无；</li>\n</ul>\n<p><a name=\"biBzT\"></a></p>\n<h4>writerMultipleRecordsInternal</h4>\n<ul>\n<li>调用位置：openInternal之后调用，开始写入多条数据</li>\n<li>作用：向数据源写入多条数据，由batchInterval参数决定写入多少条</li>\n<li>注意事项：无；</li>\n</ul>\n<p><a name=\"36baff55\"></a></p>\n<h2>ChunJun数据结构</h2>\n<p>ChunJun延续了Flink原生的数据类型Row</p>\n<pre><code class=\"language-java\">@PublicEvolving\r\npublic class Row implements Serializable{\r\n\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t/** The array to store actual values. */\r\n\tprivate final Object[] fields;\r\n\r\n\t/**\r\n\t * Create a new Row instance.\r\n\t * @param arity The number of fields in the Row\r\n\t */\r\n\tpublic Row(int arity) {\r\n\t\tthis.fields = new Object[arity];\r\n\t}\r\n}\n</code></pre>\n<p><a name=\"c79d2697\"></a></p>\n<h2>任务json配置</h2>\n<p>配置中尽量减少不必要的参数，有些参数框架中已有默认值，配置文件中的值优先，模板如下</p>\n<pre><code class=\"language-json\">{\r\n  \"job\": {\r\n    \"content\": [\r\n      {\r\n        \"reader\": {\r\n          \"parameter\": {\r\n            \"username\": \"\",\r\n            \"password\": \"\",\r\n            \"connection\": [{\r\n              \"jdbcUrl\": [\"\"],\r\n              \"table\": [\r\n                \"\"\r\n              ]\r\n            }],\r\n            \"column\": [{\r\n              \"name\": \"id\",\r\n              \"type\": \"int\"\r\n            },{\r\n              \"name\":\"name\",\r\n              \"type\":\"string\"\r\n            }]\r\n          },\r\n          \"name\": \"mysqlreader\"\r\n        },\r\n        \"writer\": {\r\n          \"parameter\": {\r\n            \"print\": true\r\n          },\r\n          \"name\": \"streamwriter\"\r\n        }\r\n      }\r\n    ],\r\n    \"setting\": {\r\n      \"errorLimit\": {\r\n      },\r\n      \"speed\": {\r\n      }\r\n    }\r\n  }\r\n}\n</code></pre>\n<p><a name=\"dd7607d3\"></a></p>\n<h2>如何设计配置参数</h2>\n<p>任务配置中<code>reader</code>和<code>writer</code>下<code>parameter</code>部分是插件的配置参数，插件的配置参数应当遵循以下原则：</p>\n<ul>\n<li>驼峰命名：所有配置项采用驼峰命名法，首字母小写，单词首字母大写。</li>\n<li>正交原则：配置项必须正交，功能没有重复，没有潜规则。</li>\n<li>富类型：合理使用json的类型，减少无谓的处理逻辑，减少出错的可能。\n<ul>\n<li>使用正确的数据类型。比如，bool类型的值使用<code>true</code>/<code>false</code>，而非<code>\"yes\"</code>/<code>\"true\"</code>/<code>0</code>等。</li>\n<li>合理使用集合类型，比如，用数组替代有分隔符的字符串。</li>\n</ul>\n</li>\n<li>类似通用：遵守同一类型的插件的习惯，比如关系型数据库的<code>connection</code>参数都是如下结构：</li>\n</ul>\n<pre><code>{\r\n  \"connection\": [\r\n    {\r\n      \"table\": [\r\n        \"table_1\",\r\n        \"table_2\"\r\n      ],\r\n      \"jdbcUrl\": [\r\n        \"jdbc:mysql://127.0.0.1:3306/database_1\",\r\n        \"jdbc:mysql://127.0.0.2:3306/database_1_slave\"\r\n      ]\r\n    },\r\n    {\r\n      \"table\": [\r\n        \"table_3\",\r\n        \"table_4\"\r\n      ],\r\n      \"jdbcUrl\": [\r\n        \"jdbc:mysql://127.0.0.3:3306/database_2\",\r\n        \"jdbc:mysql://127.0.0.4:3306/database_2_slave\"\r\n      ]\r\n    }\r\n  ]\r\n}\n</code></pre>\n<p><a name=\"cfd8aa31\"></a></p>\n<h2>如何处理脏数据</h2>\n<p><a name=\"d6acc342\"></a></p>\n<h3>脏数据定义</h3>\n<ol>\n<li>Reader读到不支持的类型、不合法的值。</li>\n<li>不支持的类型转换，比如：<code>Bytes</code>转换为<code>Date</code>。</li>\n<li>写入目标端失败，比如：写mysql整型长度超长。</li>\n</ol>\n<p><a name=\"cfd8aa31-1\"></a></p>\n<h3>如何处理脏数据</h3>\n<p>框架会将脏数据临时存放起来。由DirtyDataManager实例写入临时存放脏数据文件中。</p>\n<ul>\n<li>path: 脏数据存放路径</li>\n<li>hadoopConfig: 脏数据存放路径对应hdfs的配置信息(hdfs高可用配置)</li>\n</ul>\n<p><a name=\"605265ae\"></a></p>\n<h2>加载原理</h2>\n<ol>\n<li>框架扫描<code>plugin/reader</code>和<code>plugin/writer</code>目录，加载每个插件的<code>plugin.json</code>文件。</li>\n<li>以<code>plugin.json</code>文件中<code>name</code>为key，索引所有的插件配置。如果发现重名的插件或者不存在的插件，框架会异常退出。</li>\n<li>用户在插件中在<code>reader</code>/<code>writer</code>配置的<code>name</code>字段指定插件名字。框架根据插件的类型（<code>reader</code>/<code>writer</code>）和插件名称去插件的路径下扫描所有的jar，加入<code>classpath</code>。</li>\n<li>根据插件配置中定义的入口类，框架通过反射实例化对应的<code>Job</code>对象。</li>\n</ol>\n<p><a name=\"8e3d16c4\"></a></p>\n<h2>统一的目录结构</h2>\n<p><a name=\"sdEM2\"></a></p>\n<h4>项目目录层级</h4>\n<p>注意，插件Reader/Writer类需放在符合插件包名命名规则的reader下，如MysqlReader类需放在com.dtstack.chunjun.mysql.reader包下，具体命名规则参照 <strong>项目命名规则</strong> 内容</p>\n<pre><code class=\"language-xml\"></code></pre>\n<p>${CHUNJUN_HOME}\r\n|-- bin<br>\n|   -- flink\r\n|   -- chunjun.sh\r\n|\r\n|-- chunjun-somePlugin\r\n|-- chunjun-somePlugin-core\r\n|-- common 一些插件共用的类\r\n|-- exception 异常处理类\r\n|-- pom.xml 插件公用依赖\r\n|-- chunjun-somePlugin-reader\r\n|-- InputFormat\r\n|-- SomePluginInputFormat\r\n|-- SomePluginInputFormatBuiler\r\n|-- reader\r\n|-- SomePluginReader\r\n|-- chunjun-somePlugin-writer\r\n|-- OutputFormat\r\n|-- SomePluginOutputFormat\r\n|-- SomePluginOutputFormatBuiler\r\n|-- reader\r\n|-- SomePluginWriter</p>\n<pre><code></code></pre>\n<p><a name=\"NMw2H\"></a></p>\n<h4>项目命名规则</h4>\n<ul>\n<li>插件命名模板 [chunjun]-[dataSourceName]，例如chunjun-mysql</li>\n<li>插件模块命名模板 [chunjun]-[dataSourceName]-[reader/writer/core]，例如chunjun-mysql-reader，chunjun-redis-writer</li>\n<li>插件包名命名模板 [com.dtstack.chunjun.dataSource.xxxx]，例如com.dtstack.chunjun.mysql.reader，com.dtstack.chunjun.redis.inputformat</li>\n<li>插件Reader/Writer类命名模板 [dataSource][Reader/Writer]，例如MysqlReader，RedisWriter，需注意，类似RestAPIWriter，MetaDataHive2Reader这样的命名是错误的，需改为RestapiWriter，Metadatahive2Reader</li>\n</ul>\n<p><a name=\"dd96ac2a\"></a></p>\n<h2>插件打包</h2>\n<p>进入项目根目录，使用maven打包：</p>\n<p>windows平台</p>\n<pre><code>mvn clean package -DskipTests -Prelease -DscriptType=bat\n</code></pre>\n<p>unix平台</p>\n<pre><code>mvn clean package -DskipTests -Prelease -DscriptType=sh\n</code></pre>\n<p>打包结束后，项目根目录下会产生bin目录和plugins目录，其中bin目录包含ChunJun的启动脚本，plugins目录下存放编译好的数据同步插件包，之后就可以提交开发平台测试啦！</p>","id":"5da3deb7-fc6b-5a02-b9f2-cf4291b1daf2","parent":{"id":"5e144293-a770-5f40-8373-f3fbd007d2a6","name":"contribution","modifiedTime":"2022-06-07T13:14:11.975Z","ino":3377699721739052}}},"pageContext":{"id":"5da3deb7-fc6b-5a02-b9f2-cf4291b1daf2","parent__name":"contribution","__params":{"parent__name":"contribution"}}},"staticQueryHashes":["527733040"]}